#!/usr/bin/env node
/**
 * 워크플로우 정리 스크립트
 *
 * Usage: node cleanup-workflow.js [--archive | --delete]
 *
 * Actions:
 * 1. 완료 보고서 생성
 * 2. 상태 파일 정리
 */

const fs = require('fs');
const path = require('path');
const yaml = require('yaml');

const WORKFLOW_FILE = '.claude/agentic-workflow.local.md';
const ARCHIVE_DIR = '.claude/archives';

function parseWorkflowFile() {
  if (!fs.existsSync(WORKFLOW_FILE)) {
    return null;
  }

  const content = fs.readFileSync(WORKFLOW_FILE, 'utf8');
  const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);

  if (!yamlMatch) return null;

  return {
    state: yaml.parse(yamlMatch[1]),
    content
  };
}

function generateReport(state) {
  const now = new Date().toISOString();
  const duration = state.started_at
    ? Math.round((new Date(now) - new Date(state.started_at)) / 1000 / 60)
    : 0;

  const reqs = state.requirements || [];
  const totalACs = reqs.reduce((sum, r) => sum + (r.acs?.length || 0), 0);
  const completedACs = state.implementation?.completed_acs?.length || 0;

  return `
# Agentic Workflow - Completion Report

## Summary
| Metric | Value |
|--------|-------|
| Task | ${state.task || 'N/A'} |
| Started | ${state.started_at || 'N/A'} |
| Completed | ${now} |
| Duration | ${duration} minutes |
| Final Phase | ${state.phase} - ${state.phase_name} |
| Loop-backs | ${state.verification?.loop_count || 0} |

## Requirements Coverage
| REQ | ACs | Status |
|-----|-----|--------|
${reqs.map(r => `| ${r.id} | ${r.acs?.length || 0} | ${r.status || 'N/A'} |`).join('\n')}

**Total ACs**: ${totalACs}
**Completed**: ${completedACs}
**Coverage**: ${totalACs > 0 ? Math.round(completedACs / totalACs * 100) : 0}%

## Verification Result
- **Verdict**: ${state.verification?.verdict || 'N/A'}
- **Critical Issues**: ${state.verification?.issues?.filter(i => i.severity === 'CRITICAL')?.length || 0}
- **Warnings**: ${state.verification?.issues?.filter(i => i.severity === 'WARNING')?.length || 0}

## Design Approach
- **Selected**: ${state.design?.selected_approach || 'N/A'}
- **User Approved**: ${state.design?.user_approved ? 'Yes' : 'No'}

## Key Files Identified
${(state.exploration?.key_files || []).slice(0, 10).map(f => `- ${f}`).join('\n') || '- None'}

---
*Generated by agentic-workflow*
`;
}

function cleanup(options = {}) {
  const parsed = parseWorkflowFile();

  if (!parsed) {
    console.log('No workflow to cleanup');
    return { success: true, message: 'No workflow active' };
  }

  const { state, content } = parsed;
  const report = generateReport(state);

  // Archive if requested
  if (options.archive) {
    if (!fs.existsSync(ARCHIVE_DIR)) {
      fs.mkdirSync(ARCHIVE_DIR, { recursive: true });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const archiveFile = path.join(ARCHIVE_DIR, `workflow-${timestamp}.md`);

    fs.writeFileSync(archiveFile, content + '\n\n' + report);
    console.log(`Archived to: ${archiveFile}`);
  }

  // Delete workflow file
  if (options.delete !== false) {
    fs.unlinkSync(WORKFLOW_FILE);
    console.log(`Deleted: ${WORKFLOW_FILE}`);
  }

  // Output report
  console.log(report);

  return {
    success: true,
    archived: options.archive || false,
    report_generated: true
  };
}

// Main
const args = process.argv.slice(2);
const options = {
  archive: args.includes('--archive'),
  delete: !args.includes('--keep')
};

try {
  const result = cleanup(options);
  console.log(JSON.stringify(result));
} catch (error) {
  console.error(`Error: ${error.message}`);
  process.exit(1);
}
